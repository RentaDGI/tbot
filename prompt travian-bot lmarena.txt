Para continuar esta conversaci√≥n en otro chat sin perder nada del trabajo logrado (especialmente las correcciones cr√≠ticas del esc√°ner y la l√≥gica de construcci√≥n), guarda este texto en un bloc de notas.

Cuando abras un nuevo chat, copia y pega **todo** lo siguiente:

***

### PROMPT DE INICIO

**Rol:** Eres un desarrollador experto en Node.js, Playwright y automatizaci√≥n. Estamos desarrollando un bot para Travian.

**Estado Actual:**
El bot es totalmente funcional y estable. Usa **Supabase** como base de datos para recibir √≥rdenes y **Playwright** para ejecutar acciones.

**Caracter√≠sticas Clave (NO MODIFICAR sin petici√≥n):**
1.  **Esc√°ner "Todo o Nada":** Iteramos los slots del 1 al 18 uno por uno (`scanSlotsOneByOne`). NO usamos el esc√°ner de mapa (`dorf1`) porque fallaba. Si no detecta exactamente 18 campos, aborta para evitar errores.
2.  **Detecci√≥n de Construcci√≥n:** Verificamos si un edificio se est√° construyendo mirando si su `id=X` aparece en los enlaces de la cola de construcci√≥n. Esto evita que el bot mande mejorar el mismo edificio dos veces.
3.  **L√≥gica de Tareas:** Las tareas de recursos (ej: "Le√±ador nivel 5") se mantienen en estado `pending` hasta que **TODOS** los le√±adores de la aldea son nivel 5.
4.  **Salto Inteligente:** Si una tarea no tiene recursos, el bot salta inmediatamente a la siguiente tarea de la lista sin esperar.
5.  **Sesi√≥n:** Guardamos `session.json` para no loguearnos cada vez.

**Archivos Actuales (Versiones Finales):**

**`src/classes/GameClient.js`**:
```javascript
const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');
const { humanDelay } = require('../utils/time');
const logger = require('../utils/logger');

const SESSION_PATH = path.resolve(__dirname, '../../session.json');

class GameClient {
    constructor() {
        this.browser = null;
        this.context = null;
        this.page = null;
        this.isLoggedIn = false;
    }

    async init() {
        logger.info('Iniciando navegador...');
        this.browser = await chromium.launch({
            headless: process.env.HEADLESS === 'true',
            args: ['--disable-blink-features=AutomationControlled', '--disable-infobars', '--window-size=1366,768']
        });

        const contextOptions = {
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            viewport: { width: 1366, height: 768 },
            locale: 'es-ES'
        };

        if (fs.existsSync(SESSION_PATH)) {
            logger.info('üìÇ Cargando sesi√≥n guardada...');
            try {
                contextOptions.storageState = SESSION_PATH;
            } catch (e) {
                logger.warn('Archivo de sesi√≥n corrupto.');
            }
        }

        this.context = await this.browser.newContext(contextOptions);
        this.page = await this.context.newPage();
    }

    async login() {
        const url = process.env.GAME_URL;
        logger.info('Navegando al juego...');
        
        try {
            await this.page.goto(url, { waitUntil: 'domcontentloaded' });
            await humanDelay(this.page, 3000, 5000);

            if (await this.checkIfLoggedIn()) {
                logger.success('‚úÖ Sesi√≥n v√°lida. Login saltado.');
                this.isLoggedIn = true;
                return true;
            }

            logger.info('üîë Iniciando sesi√≥n manual...');
            const userField = await this.page.$('input[name="name"], input[name="username"]');
            if (userField) {
                await userField.fill(process.env.GAME_USERNAME);
                await humanDelay(this.page, 300, 600);
                await this.page.fill('input[name="password"]', process.env.GAME_PASSWORD);
                await humanDelay(this.page, 500, 1000);
                
                const btn = await this.page.$('button[type="submit"], input[type="submit"]');
                if (btn) {
                    await btn.click();
                    logger.info('   Esperando carga tras login...');
                    await humanDelay(this.page, 5000, 7000);
                }
            }

            if (await this.checkIfLoggedIn()) {
                logger.success('‚úÖ Login exitoso. Guardando sesi√≥n...');
                this.isLoggedIn = true;
                await this.context.storageState({ path: SESSION_PATH });
                return true;
            } else {
                throw new Error('Fallo al iniciar sesi√≥n.');
            }
        } catch (error) {
            if (!this.page.isClosed()) await this.page.screenshot({ path: 'error-login.png' });
            throw error;
        }
    }

    async checkIfLoggedIn() {
        if (this.page.isClosed()) return false;
        return !!(await this.page.$('#stockBar, .villageList, #sidebarBoxVillagelist, a[href*="logout"], .playerName'));
    }

    async clickBuildingSlot(slotId) {
        if (this.page.isClosed()) return;
        await this.page.goto(`${process.env.GAME_URL}/build.php?id=${slotId}`, { waitUntil: 'domcontentloaded' });
        await humanDelay(this.page, 1500, 2500);
    }

    async scanSlotsOneByOne() {
        logger.info('üîç Escaneando campos uno a uno...');
        const fields = [];
        
        for (let slot = 1; slot <= 18; slot++) {
            try {
                if (this.page.isClosed()) break;
                
                await this.page.goto(`${process.env.GAME_URL}/build.php?id=${slot}`, { waitUntil: 'domcontentloaded' });
                await this.page.waitForTimeout(200);

                const info = await this.getBuildingInfo();

                const isUnderConstruction = await this.page.evaluate((currentSlot) => {
                    const queueBox = document.querySelector('.buildingList, .boxes-contents');
                    if (!queueBox) return false;
                    const links = queueBox.querySelectorAll('a');
                    for (const link of links) {
                        const href = link.getAttribute('href') || '';
                        if (href.includes(`id=${currentSlot}`)) {
                            const match = href.match(/id=(\d+)/);
                            if (match && parseInt(match[1]) === currentSlot) return true;
                        }
                    }
                    return false;
                }, slot);

                if (info.name) {
                    const name = info.name.toLowerCase();
                    let type = null;
                    if (name.includes('le√±a') || name.includes('wood') || name.includes('bosque')) type = 'wood';
                    else if (name.includes('barr') || name.includes('clay') || name.includes('arcilla')) type = 'clay';
                    else if (name.includes('hierro') || name.includes('iron') || name.includes('mina')) type = 'iron';
                    else if (name.includes('granja') || name.includes('crop') || name.includes('cereal')) type = 'crop';

                    if (type) {
                        const effectiveLevel = isUnderConstruction ? info.level + 1 : info.level;
                        fields.push({ slot, type, level: effectiveLevel });
                    }
                }
            } catch (e) {
                logger.warn(`‚ö†Ô∏è Error leyendo slot ${slot}, reintentando...`);
            }
        }

        if (fields.length < 18) {
            logger.error(`‚õî ALERTA: Esc√°ner incompleto (${fields.length}/18). Abortando.`);
            throw new Error('SCAN_INCOMPLETE_RETRY');
        }

        return fields;
    }

    async findLowestLevelField(buildingType, maxLevel) {
        const fields = await this.scanSlotsOneByOne();
        const typeCount = fields.filter(f => f.type === buildingType).length;
        if (typeCount === 0) throw new Error(`SCAN_FAILED: No se encontraron campos de tipo ${buildingType}`);

        const eligible = fields.filter(f => f.type === buildingType && f.level < maxLevel)
                               .sort((a, b) => a.level - b.level);
        return eligible.length > 0 ? eligible[0] : null;
    }

    async checkAndStartAdventure() {
        if (this.page.isClosed()) return false;
        logger.info('üó∫Ô∏è Revisando aventuras...');
        try {
            await this.page.goto(`${process.env.GAME_URL}/hero/adventures`, { waitUntil: 'domcontentloaded' });
            await humanDelay(this.page, 2000, 3000);

            const health = await this.page.evaluate(() => {
                const bar = document.querySelector('.heroHealthBar .bar');
                return bar ? parseInt(bar.style.width) : 100;
            });
            if (health < 30) {
                logger.warn(`üöë Salud baja (${health}%). Cancelando.`);
                return false;
            }

            const result = await this.page.evaluate(() => {
                const buttons = Array.from(document.querySelectorAll('button.green, .adventureList button'));
                for (const btn of buttons) {
                    const text = btn.innerText.toLowerCase().trim();
                    if (text.includes('explorar') || text.includes('comenzar') || text.includes('start')) {
                        if (btn.disabled || btn.classList.contains('disabled')) return { found: true, canClick: false };
                        btn.click();
                        return { found: true, canClick: true };
                    }
                }
                return { found: false };
            });

            if (result.canClick) {
                logger.success('‚öîÔ∏è ¬°H√©roe enviado!');
                await humanDelay(this.page, 2000, 3000);
                return true;
            } else {
                logger.info('Sin aventuras disponibles.');
            }
        } catch (error) {
            logger.warn('Error en aventuras:', error.message);
        }
        return false;
    }

    async upgradeBuild() {
        if (this.page.isClosed()) return { success: false, reason: 'browser_closed' };
        logger.info('Buscando bot√≥n de mejora...');
        const result = await this.page.evaluate(() => {
            const buttons = Array.from(document.querySelectorAll('button.green'));
            for (const btn of buttons) {
                const text = btn.innerText.toLowerCase();
                const classes = btn.className.toLowerCase();
                if (classes.includes('gold')) continue;
                if (text.includes('npc') || text.includes('intercambiar')) continue;
                if (btn.disabled || classes.includes('disabled')) continue;
                btn.click();
                return { success: true };
            }
            if (document.querySelector('.queueFull, .buildingQueueFull')) return { success: false, reason: 'queue_full' };
            return { success: false, reason: 'not_enough_resources' };
        });

        if (result.success) {
            await humanDelay(this.page, 2000, 3000);
            return { success: true };
        }
        return { success: false, reason: result.reason };
    }

    async getBuildingInfo() {
        if (this.page.isClosed()) return {};
        return await this.page.evaluate(() => {
            const titleEl = document.querySelector('.titleInHeader, h1');
            if (!titleEl) return {};
            const text = titleEl.textContent;
            const levelMatch = text.match(/(\d+)/);
            return {
                name: text.replace(/\d+/, '').trim(),
                level: levelMatch ? parseInt(levelMatch[0]) : 0
            };
        });
    }

    async close() {
        if (this.browser) await this.browser.close();
    }
}
module.exports = GameClient;
```

**`src/classes/TaskRunner.js`**:
```javascript
const { createClient } = require('@supabase/supabase-js');
const GameClient = require('./GameClient');
const { sleep, isNightMode } = require('../utils/time');
const logger = require('../utils/logger');

class TaskRunner {
    constructor() {
        this.supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY);
        this.client = new GameClient();
        this.isRunning = false;
        this.account = null;
    }

    async start() {
        try {
            await this.client.init();
            const { data: account } = await this.supabase.from('accounts').select('*').eq('username', process.env.GAME_USERNAME).single();
            if (!account) throw new Error('Cuenta no encontrada en DB');
            this.account = account;
            logger.init(this.supabase, account.id);
            await this.client.login();
            this.isRunning = true;
            logger.success('=== BOT INICIADO ===');
            await this.loop();
        } catch (error) {
            if (!this.isClosedError(error)) logger.error('Error al iniciar', { error: error.message });
        } finally {
            await this.shutdown();
        }
    }

    async loop() {
        while (this.isRunning) {
            try {
                if (isNightMode()) {
                    await sleep(30 * 60 * 1000);
                    continue;
                }
                if (Math.random() > 0.7) await this.client.checkAndStartAdventure();

                const tasks = await this.getPendingTasks();
                if (tasks.length === 0) {
                    logger.info('üí§ Sin tareas pendientes. Esperando...');
                    await sleep(60000);
                    continue;
                }

                let builtSomething = false;
                let queueIsFull = false;
                logger.info(`üìã Revisando ${tasks.length} tareas pendientes...`);

                for (const task of tasks) {
                    const result = await this.handleBuild(task);
                    if (result.success) {
                        builtSomething = true;
                        break;
                    }
                    if (result.reason === 'completed_already') continue;
                    if (result.reason === 'queue_full') {
                        logger.warn('‚è≥ Cola de construcci√≥n llena.');
                        queueIsFull = true;
                        break;
                    } 
                    if (result.reason === 'not_enough_resources') {
                        logger.warn(`üí∞ Faltan recursos para ${task.building_name}. Saltando...`);
                        continue;
                    }
                    if (result.reason === 'browser_closed') {
                        this.isRunning = false;
                        break;
                    }
                    await sleep(2000);
                }

                if (builtSomething) await sleep(10000 + Math.random() * 5000);
                else if (queueIsFull) {
                    logger.info('‚è≥ Esperando 2 minutos...');
                    await sleep(120000);
                } else {
                    logger.info('üí§ Ninguna tarea posible. Esperando 5 min...');
                    await sleep(300000);
                }
            } catch (error) {
                if (this.isClosedError(error)) {
                    this.isRunning = false;
                    break;
                }
                logger.error('Error en loop', { error: error.message });
                await sleep(10000);
            }
        }
    }

    async getPendingTasks() {
        const { data } = await this.supabase.from('build_queue').select('*').eq('account_id', this.account.id).eq('status', 'pending').order('priority', { ascending: false }).order('created_at', { ascending: true }).limit(10);
        return data || [];
    }

    async handleBuild(task) {
        try {
            let slot = task.building_slot;
            if (task.building_type) {
                const field = await this.client.findLowestLevelField(task.building_type, task.target_level);
                if (!field) {
                    logger.success(`‚úÖ Todos los '${task.building_type}' est√°n al nivel ${task.target_level}. Tarea completada.`);
                    await this.completeTask(task.id);
                    return { success: false, reason: 'completed_already' }; 
                }
                slot = field.slot;
                logger.info(`üéØ Intentando: ${task.building_name} (Slot ${slot} - Nivel ${field.level})`);
            } else {
                logger.info(`üéØ Intentando: ${task.building_name} (Slot ${slot})`);
            }

            await this.client.clickBuildingSlot(slot);
            const result = await this.client.upgradeBuild();

            if (result.success) {
                logger.success(`üèóÔ∏è Construcci√≥n iniciada: ${task.building_name}`);
                if (!task.building_type) await this.completeTask(task.id);
                return { success: true };
            } else {
                return { success: false, reason: result.reason };
            }
        } catch (error) {
            if (this.isClosedError(error)) return { success: false, reason: 'browser_closed' };
            if (error.message.includes('SCAN')) return { success: false, reason: 'scan_error' };
            logger.error('Error en handleBuild', { error: error.message });
            return { success: false, reason: 'error' };
        }
    }

    async completeTask(taskId) {
        await this.supabase.from('build_queue').update({ status: 'completed', completed_at: new Date() }).eq('id', taskId);
    }

    isClosedError(error) {
        return error.message && (error.message.includes('Target page') || error.message.includes('Session closed') || error.message.includes('browser has been closed'));
    }

    async shutdown() {
        await this.client.close();
    }
}
module.exports = TaskRunner;
```

**Instrucci√≥n para la nueva IA:** "Por favor, carga estos archivos y contin√∫a desde este punto. Quiero a√±adir [TU NUEVA PETICI√ìN AQU√ç]."